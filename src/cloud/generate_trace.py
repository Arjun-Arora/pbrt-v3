import sys
import struct
import json
from concurrent.futures import ThreadPoolExecutor
import random
import tarfile
import os
import argparse
from collections import defaultdict

def read_intervals(path: str):
    worker_intervals = {}
    with open(path, 'r') as f:
        for line in f:
            tokens = line.split(' ')
            worker_id = int(tokens[1])
            num_actions = int(tokens[2])
            offset = 3
            intervals = []
            for _ in range(num_actions):
                action_name = tokens[offset]
                num_intervals = int(tokens[offset + 1])
                offset += 2
                for n in range(num_intervals):
                    start, end = tokens[offset + n].split(',')
                    intervals.append((action_name, int(start), int(end)))
                offset += num_intervals
            worker_intervals[worker_id] = intervals
    return worker_intervals


def write_trace(worker_intervals, path: str):
    """
    Generates a trace file in Chrome format.

    To visualize the trace, visit chrome://tracing in Google Chrome and
    click "Load" in the top left to load the trace.

    Args
    ----
    path
      Output path to write the trace.
    """

    # https://github.com/catapult-project/catapult/blob/master/tracing/tracing/base/color_scheme.html
    colors = {'idle': 'grey'}
    traces = []
    next_tid = 0

    def make_trace_from_interval(interval, proc, tid):
        name, start, end = interval
        cat = ''
        trace = {
            'name': name,
            'cat': cat,
            'ph': 'X',
            'ts': start / 1000,  # ns to microseconds
            'dur': (end - start) / 1000,
            'pid': proc,
            'tid': tid,
            'args': {}
        }
        if interval[0] in colors:
            trace['cname'] = colors[interval[0]]
        return trace


    if False and self._master_profiler is not None:
        traces.append({
            'name': 'thread_name',
            'ph': 'M',
            'pid': -1,
            'tid': 0,
            'args': {'name': 'master'}
        })

        for interval in self._master_profiler[1]['intervals']:
            traces.append(make_trace_from_interval(interval, 'master', -1, 0))

    for worker_id, intervals in worker_intervals.items():
        tid = next_tid
        next_tid += 1
        worker_num = worker_id
        tag = None
        proc = worker_id

        print('Generating traces for worker {:d}...'.format(tid))

        traces.append({
            'name': 'thread_name',
            'ph': 'M',
            'pid': proc,
            'tid': tid,
            'args': {
                'name':
                '{:06d}'.format(worker_num) +
                ("_" + str(tag) if tag else "")
            }
        })
        for interval in intervals:
            traces.append(make_trace_from_interval(interval, proc, tid))

    parts = path.split('.')
    base = parts[0]
    exts = parts[1:]
    with open(base + '.trace', 'w') as f:
        f.write(json.dumps(traces))

    if exts == ['trace']:
        return path

    elif exts == ['tar', 'gz']:
        with tarfile.open(base + '.tar.gz', 'w:gz') as tar:
            tar.add(base + '.trace')
        os.remove(base + '.trace')
        return path

    else:
        raise Exception("Invalid trace extension '{}'. Must be .trace or .tar.gz." \
                        .format(''.join(['.' + e for e in exts])))


def main():
    parser = argparse.ArgumentParser(description=(
        'Generate a trace file for viewing in chrome://tracing from cloud pbrt worker intervals.'))
    parser.add_argument('--worker-intervals-path', default='worker_intervals.txt',
                        help=(
                            'Path to the worker_intervals.txt generated by '
                            'pbrt-lambda-master after finished a run.'))
    parser.add_argument('--output-path', default='pbrt.tar.gz',
                        help='Path to write the compressed trace file to.')
    args = parser.parse_args()

    print('Reading worker intervals from {:s}'.format(args.worker_intervals_path))
    intervals = read_intervals(args.worker_intervals_path)
    path = write_trace(intervals, args.output_path)
    print('Wrote trace to {:s}.'.format(path))


if __name__ == "__main__":
    main()
